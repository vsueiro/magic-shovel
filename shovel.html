<!DOCTYPE html>
<html translate="no">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TunnelSimulator — Shovel Attachment</title>

    <style>

    * {
      overflow: hidden
    }

    html {
      background: black;
      color: white;
    }

    canvas {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: -1;
    }

    </style>

  </head>
  <body>

    <canvas class="canvas"></canvas>
    <button class="track">Enable motion sensor</button>
    <pre>
0
0
0
    </pre>

    <!-- https://unpkg.com/browse/three@0.124.0/build/three.min.js -->
    <script src="js/three.min.js"></script>

    <!-- https://unpkg.com/browse/three@0.124.0/examples/js/controls/OrbitControls.js -->
    <script src="js/OrbitControls.js"></script>

    <!-- https://unpkg.com/three@0.124.0/examples/js/renderers/CSS2DRenderer.js -->
    <script src="js/CSS2DRenderer.js"></script>

    <!-- Custom -->

    <script>

    let app = {

      elements : {

        canvas : document.querySelector( '.canvas' ),
        trackButton : document.querySelector( '.track' ),

      },

      data : {

        orientation : {
          alpha : 0,
          beta  : 0,
          gamma : 0,
        },

        earth : {
          radius : {
            crust : 6371
          }
        }

      },

      three : {

        world          : {
          x            : new THREE.Vector3( 1, 0, 0 ),
          y            : new THREE.Vector3( 0, 1, 0 ),
          z            : new THREE.Vector3( 0, 0, 1 ),
        },

        renderer       : undefined,
        camera         : undefined,
        scene          : undefined,
        controls       : undefined,

        tunnel         : undefined, // Group
        cylinder       : undefined,
        chord          : undefined,


        create : {

          cylinder : () => {

            let geometry = new THREE.CylinderGeometry(
              app.data.earth.radius.crust / 20,
              app.data.earth.radius.crust / 20,
              app.data.earth.radius.crust * 2,
              6,
              32
            );

            let material = new THREE.MeshBasicMaterial( {
                color: 0xff0000,
                wireframe: true,
                opacity: 1,
                transparent: true
            } );

            // Rotates around end, not center
            // app.three.tunnelGeometry.translate( 0, -app.data.earth.radius.crust, 0);

            app.three.cylinder = new THREE.Mesh( geometry, material );
            // app.three.tunnel.position.z = app.data.earth.radius.crust;

          },

          tunnel : () => {

            app.three.tunnel = new THREE.Group();

            app.three.tunnel.add(
              app.three.cylinder
            );

          }

        },

        initialize : () => {

          app.three.create.cylinder();
          app.three.create.tunnel();





          // Begins renderer with transparent background
          app.three.renderer = new THREE.WebGLRenderer( {
            canvas : app.elements.canvas,
            alpha : true,
            logarithmicDepthBuffer: true // prevents z fighting
          } );

          // Creates camera
          app.three.camera = new THREE.PerspectiveCamera( 50, 1, .1, app.data.earth.radius.crust * 30 );
          app.three.camera.position.y = app.data.earth.radius.crust * 3;

          // Makes camera move with mouse
          app.three.controls = new THREE.OrbitControls(
            app.three.camera,
            app.elements.canvas
          );

          // Makes camera move automatically and with inertia
          app.three.controls.enableDamping   = true;
          app.three.controls.enableZoom      = false;
          app.three.controls.enablePan       = false;

          // Creates scene
          app.three.scene = new THREE.Scene();
          app.three.scene.add( app.three.tunnel );

          // Debugs axes
          let axesHelper = new THREE.AxesHelper( 1000 );
          app.three.scene.add( axesHelper );

          // Animate 3D elements
          requestAnimationFrame( app.three.render );

        },

        render : ( time ) => {

          // Makes canvas responsive
          app.three.resize();

          // Rotates tunnel according to readings
          app.three.cylinder.rotation.x = THREE.Math.degToRad( app.data.orientation.beta  );
          app.three.tunnel.rotation.y   = THREE.Math.degToRad( app.data.orientation.alpha );
          app.three.cylinder.rotation.z = THREE.Math.degToRad( app.data.orientation.gamma );

          // Makes camera orbit
          app.three.controls.update();

          app.three.renderer.render(
            app.three.scene,
            app.three.camera
          );

          // Enables recursion (this function calls itself to draw frames of 3D animation)
          requestAnimationFrame( app.three.render );

        },

        resize : () => {

          let c = app.elements.canvas;

          // If canvas dimensions are different from window dimensios
          if ( c.width !== c.clientWidth || c.height !== c.clientHeight ) {

            // Resizes
            app.three.renderer.setSize(
              c.clientWidth,
              c.clientHeight,
              false
            );

            // Updates camera accordingly
            app.three.camera.aspect = c.clientWidth / c.clientHeight;
            app.three.camera.updateProjectionMatrix();

          }

        }

      },

      orientation : {

        handle : () => {

          // Implements world-based calibration on iOS (alpha is 0 when pointing North), based on:
          // https://www.w3.org/2008/geolocation/wiki/images/e/e0/Device_Orientation_%27alpha%27_Calibration-_Implementation_Status_and_Challenges.pdf

          let north, offset;

          // If alpha is absolute (0 points North)
          if ( event.absolute === true ) {

            // Uses incoming value
            north = event.alpha;

          } else { // If alpha is relative

            // Calibrates alpha to make it North-based
            offset = event.webkitCompassHeading || 0;
            north  = event.alpha - offset;

            if ( north < 0 )
              north += 360;

          }

          // Prints values for debugging
          let pre = document.querySelector( 'pre' )

          pre.textContent = ''
          pre.textContent += 'north:    ' + north.toFixed(2) + '\n';
          pre.textContent += '\n';
          pre.textContent += 'alpha:    ' + event.alpha.toFixed(2) + '\n';
          pre.textContent += 'beta:     ' + event.beta.toFixed(2)  + '\n';
          pre.textContent += 'gamma:    ' + event.gamma.toFixed(2) + '\n';
          pre.textContent += '\n';
          pre.textContent += 'absolute: ' + event.absolute;
          pre.textContent += '\n';
          pre.textContent += 'webkitCompassHeading:  ' + event.webkitCompassHeading + '\n';
          pre.textContent += 'webkitCompassAccuracy: ' + event.webkitCompassAccuracy + '\n';


          // Updates values to be used by render method
          app.data.orientation.alpha = north;
          app.data.orientation.beta  = event.beta;
          app.data.orientation.gamma = event.gamma * -1;

        },

        request : () => {

          // Requests permission for iOS 13+ devices
          if ( DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function' ) {

            DeviceMotionEvent.requestPermission()
            .then( response => {

              if ( response == 'granted' ) {

                // Enables orientationControl
                // app.options.orientationControl = true;
                // app.steps.next()

                window.addEventListener( 'deviceorientation', app.orientation.handle );

              }

            } );

          }

        }

      },

      events : {

        initialize : () => {

          // Tracks phone’s orientation when clicked
          app.elements.trackButton.addEventListener( 'click', app.orientation.request );

        }

      },

      initialize : () => {

        app.three.initialize();
        app.events.initialize();

      }

    }

    app.initialize();

    </script>

  </body>
</html>
