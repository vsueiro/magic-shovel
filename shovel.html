<!DOCTYPE html>
<html translate="no">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TunnelSimulator — Shovel Attachment</title>

    <style>

    * {
      overflow: hidden
    }

    html {
      background: black;
      color: white;
    }

    canvas {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: -1;
    }

    </style>

  </head>
  <body>

    <canvas class="canvas"></canvas>
    <button class="track">Enable motion sensor</button>
    <pre>
0
0
0
    </pre>

    <!-- https://unpkg.com/browse/three@0.124.0/build/three.min.js -->
    <script src="js/three.min.js"></script>

    <!-- https://unpkg.com/browse/three@0.124.0/examples/js/controls/OrbitControls.js -->
    <script src="js/OrbitControls.js"></script>

    <!-- https://unpkg.com/three@0.124.0/examples/js/renderers/CSS2DRenderer.js -->
    <script src="js/CSS2DRenderer.js"></script>

    <!-- Custom -->

    <script>

    let app = {

      elements : {

        canvas : document.querySelector( '.canvas' ),
        trackButton : document.querySelector( '.track' ),

      },

      data : {

        earth : {
          radius : {
            crust : 6371
          }
        }

      },

      three : {

        renderer       : undefined,
        camera         : undefined,
        scene          : undefined,
        controls       : undefined,
        materials      : {},
        geometries     : {},

        tunnel         : undefined,

        initialize : () => {

          // Tunnel

          app.three.geometries.tunnel = new THREE.CylinderGeometry(
            app.data.earth.radius.crust / 20,
            app.data.earth.radius.crust / 20,
            app.data.earth.radius.crust * 2,
            6,
            32
          );

          app.three.materials.tunnel = new THREE.MeshBasicMaterial( {
              color: 0xff0000,
              wireframe: true,
              opacity: 1,
              transparent: true
          } );

          // Rotates around end, not center
          // app.three.tunnelGeometry.translate( 0, -app.data.earth.radius.crust, 0);

          app.three.tunnel = new THREE.Mesh(
            app.three.geometries.tunnel,
            app.three.materials.tunnel
          );
          // app.three.tunnel.position.z = app.data.earth.radius.crust;


          // Begins renderer with transparent background
          app.three.renderer = new THREE.WebGLRenderer(
            {
              canvas : app.elements.canvas,
              alpha : true,
              logarithmicDepthBuffer: true // prevents z fighting
            }
        );

          // Creates camera
          app.three.camera = new THREE.PerspectiveCamera( 50, 1, .1, app.data.earth.radius.crust * 30 );
          app.three.camera.position.z = app.data.earth.radius.crust * 3;

          // Makes camera move with mouse
          app.three.controls = new THREE.OrbitControls(
            app.three.camera,
            app.elements.canvas
          );

          // Makes camera move automatically and with inertia
          app.three.controls.enableDamping   = true;
          app.three.controls.enableZoom      = false;
          app.three.controls.enablePan       = false;

          // Creates scene
          app.three.scene = new THREE.Scene();
          app.three.scene.add( app.three.tunnel );

          // Debugs axes
          let axesHelper = new THREE.AxesHelper( 1000 );
          app.three.scene.add( axesHelper );

          // Animate 3D elements
          requestAnimationFrame( app.three.render );

        },

        render : ( time ) => {

          // Makes canvas responsive
          app.three.resize();

          // Makes camera orbit
          app.three.controls.update();

          app.three.renderer.render(
            app.three.scene,
            app.three.camera
          );

          // Enables recursion (this function calls itself to draw frames of 3D animation)
          requestAnimationFrame( app.three.render );

        },

        resize : () => {

          let c = app.elements.canvas;

          // If canvas dimensions are different from window dimensios
          if ( c.width !== c.clientWidth || c.height !== c.clientHeight ) {

            // Resizes
            app.three.renderer.setSize(
              c.clientWidth,
              c.clientHeight,
              false
            );

            // Updates camera accordingly
            app.three.camera.aspect = c.clientWidth / c.clientHeight;
            app.three.camera.updateProjectionMatrix();

          }

        }

      },

      orientation : {

        handle : () => {

          let pre = document.querySelector( 'pre' )

          pre.textContent = ''
          pre.textContent += 'alpha:    ' + event.alpha.toFixed(2) + '\n';
          pre.textContent += 'beta:     ' + event.beta.toFixed(2)  + '\n';
          pre.textContent += 'gamma:    ' + event.gamma.toFixed(2) + '\n';
          pre.textContent += '\n';
          pre.textContent += 'absolute: ' + event.absolute;
          pre.textContent += '\n';
          pre.textContent += 'webkitCompassHeading:  ' + event.webkitCompassHeading;
          pre.textContent += 'webkitCompassAccuracy: ' + event.webkitCompassAccuracy;

          // Implements world-based calibration on iOS (alpha is 0 when pointing North), based on:
          // https://www.w3.org/2008/geolocation/wiki/images/e/e0/Device_Orientation_%27alpha%27_Calibration-_Implementation_Status_and_Challenges.pdf

          /*

          if ( app.data.orientation.initialOffset === undefined && event.absolute !== true )
            app.data.orientation.initialOffset = event.webkitCompassHeading || 0;

          let alpha = event.alpha;

          // Calibrates alpha to make it North-based
          if ( event.absolute !== true )
            alpha = alpha - app.data.orientation.initialOffset;

          if ( alpha < 0 )
            alpha +=360;

          // Updates values to be used on render function
          app.data.orientation.alpha = alpha;
          app.data.orientation.beta  = event.beta;
          app.data.orientation.gamma = event.gamma;

          */

        },

        request : () => {

          // Requests permission for iOS 13+ devices
          if ( DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function' ) {

            DeviceMotionEvent.requestPermission()
            .then( response => {

              if ( response == 'granted' ) {

                // Enables orientationControl
                // app.options.orientationControl = true;
                // app.steps.next()

                window.addEventListener( 'deviceorientation', app.orientation.handle );

              }

            } );

          }

        }

      },

      events : {

        initialize : () => {

          // Tracks phone’s orientation when clicked
          app.elements.trackButton.addEventListener( 'click', app.orientation.request );

        }

      },

      initialize : () => {

        app.three.initialize();
        app.events.initialize();

      }

    }

    app.initialize();

    </script>

  </body>
</html>
