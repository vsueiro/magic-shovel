<html>

	<head>
		<meta charset="utf8">
		<style>
			* {
				margin: 0;
				padding: 0;
				font-family: sans-serif;
			}
			#demo {
				position: relative;
				width: 100%;
				height: 100%;
				overflow: hidden;
			}
			#demo > canvas {
				z-index: 1;
			}

		</style>
	</head>

	<body>

	<div id="demo"></div>

	<!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script> -->
	<script src="three.min.js"></script> <!-- 124 -->
	<script>

	function Map3DGeometry (data) {

		THREE.Geometry.call (this);
		// data.vertices = [lat, lon, ...]
		// data.polygons = [[poly indices, hole i-s, ...], ...]
		// data.triangles = [tri i-s, ...]
		let i, uvs = [];
		for (i = 0; i < data.vertices.length; i += 2) {
			let lon = data.vertices[i];
			let lat = data.vertices[i + 1];
			// colatitude
			let phi = +(90 - lat) * 0.01745329252;
			// azimuthal angle
			let the = +(180 - lon) * 0.01745329252;
			// translate into XYZ coordinates
			let wx = Math.sin (the) * Math.sin (phi) * -1;
			let wz = Math.cos (the) * Math.sin (phi);
			let wy = Math.cos (phi);
			// equirectangular projection
			let wu = 0.25 + lon / 360.0;
			let wv = 0.5 + lat / 180.0;

			this.vertices.push (new THREE.Vector3 (wx, wy, wz));

			uvs.push (new THREE.Vector2 (wu, wv));
		}

		let n = this.vertices.length;

		for (i = 0; i < n; i++) {
			let v = this.vertices[i];
			this.vertices.push (v.clone ().multiplyScalar (0));
		}

		for (i = 0; i < data.triangles.length; i += 3) {
			let a = data.triangles[i];
			let b = data.triangles[i + 1];
			let c = data.triangles[i + 2];

			this.faces.push( new THREE.Face3( a, b, c, [ this.vertices[a], this.vertices[b], this.vertices[c] ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ], uvs[ b ], uvs[ c ] ]);
		}

		this.computeFaceNormals ();

		this.boundingSphere = new THREE.Sphere (new THREE.Vector3 (), 1);
	}

	Map3DGeometry.prototype = Object.create (THREE.Geometry.prototype);
	</script>

	<script>

	function demo(countries) {

		let scene = new THREE.Scene();

		let camera = new THREE.PerspectiveCamera();
		camera.position.set(0, 600, 800);
		camera.lookAt(scene.position);
		scene.add(camera);

		// let renderer, land, water, radius;

			let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

			let material = new THREE.MeshNormalMaterial()
			material.side = THREE.DoubleSide;
			// let water = new THREE.MeshBasicMaterial({color: 0xAAAAFF, wireframe:true})
			let radius = 10000;

		let container = document.getElementById('demo');
		container.appendChild(renderer.domElement);


		let land = new THREE.Object3D ();
		land.scale.set (250, 250, 250);
		scene.add (land);


		for (let name in countries) {
			geometry = new Map3DGeometry (countries[name]);
			land.add (countries[name].mesh = new THREE.Mesh (geometry, material));
			countries[name].mesh.name = name;
		}

		let resize = function () {
			let w = renderer.domElement.parentElement.clientWidth;
			let h = renderer.domElement.parentElement.clientHeight;
			// notify the renderer of the size change
			renderer.setSize(w, h);
			// update the camera
			camera.aspect = w / h;
			camera.updateProjectionMatrix();
		};

		let render = function () {
			requestAnimationFrame (render);
			land.rotation.y += 0.01;
			renderer.render (scene, camera);
		};

		window.addEventListener('resize', resize, false);

		resize();
		render();

	}

	// Gets countries geometries
	fetch('countries.json')
   .then(response => response.json())
   .then(countries => demo(countries))

	</script>

	</body>

</html>
